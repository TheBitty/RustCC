---
description: 
globs: 
alwaysApply: false
---
# Cursor Agent Rules: Best Practices for AI-Assisted Code Generation

## Core Rules

### 1. Always prefer simple solutions
**Why this matters:** Simple solutions are easier to understand, debug, and maintain. Complex solutions often introduce unnecessary dependencies and edge cases that can lead to bugs.

Complexity grows exponentially with code size, and each additional component or pattern introduces multiple potential failure points. A cursor agent should strive for solutions that solve the problem with minimal complexity, even if they're slightly less elegant or "clever."

### 2. Avoid duplication of code whenever possible
**Why this matters:** Duplicated code leads to maintenance nightmares where changes need to be made in multiple places, increasing the chance of inconsistencies.

Before generating new code, the cursor agent should scan the existing codebase for similar patterns or functionality. This not only prevents duplication but also helps maintain a consistent coding style across the project.

### 3. Write code that takes into account different environments
**Why this matters:** Code that works in development might fail in production due to different configurations, security restrictions, or scale requirements.

Environment-aware code uses configuration injection rather than hardcoded values and gracefully handles environment-specific conditions. Consider how the code will behave in development, testing, and production environments.

### 4. Be very careful to only make changes that are requested
**Why this matters:** Scope creep is a major source of bugs and unexpected behavior. Changes outside the requested scope might interact with parts of the system in ways that aren't immediately apparent.

A cursor agent should resist the temptation to "improve" code beyond what was specifically requested unless there's a clear, compelling reason directly related to the original task.

### 5. Exhaust existing implementation options before introducing new patterns
**Why this matters:** Introducing new patterns creates inconsistency in the codebase and increases cognitive load for developers. It can also introduce new bugs or edge cases that weren't present in the original implementation.

When a cursor agent suggests fixes, it should first attempt to work within the existing patterns and only propose new approaches when the current implementation is fundamentally flawed or incapable of handling the requirements. If a new pattern, algorithm, or technology is introduced, ensure the old implementation is completely removed.

## Additional Recommended Rules

### No Mock Data
Never include mock data in production code. All test data should be kept in separate test files or fixtures. Using mock data in production code can lead to security issues, bugs, and confusion.

### File Size Management
Keep files under 200-400 lines of code. When a file exceeds this limit, refactor it into smaller, more focused modules. Large files are harder to understand, test, and maintain. Breaking them down into logical components improves readability and reduces cognitive load.

### No Stubbing or Fake Data
Never add stubbing or fake data implementations in production code. Temporary implementations often become permanent technical debt. Instead, implement the full solution or use proper dependency injection to handle not-yet-implemented components.

### Environment Variables Protection
Never overwrite .env variables in code. Environment variables should be treated as external configuration that should not be modified programmatically. Overwriting them can lead to unexpected behavior and configuration inconsistencies across environments.

### Documentation and Comments
Add clear, concise comments explaining WHY code works a certain way, not just WHAT it does. Comments should focus on explaining non-obvious design decisions, potential edge cases, or complex algorithms rather than simply restating what the code does.

### Error Handling
Implement robust error handling with informative error messages and appropriate recovery strategies. Proper error handling prevents cascading failures and makes debugging easier.

### Performance Considerations
Consider performance implications for operations that might scale, especially in loops or recursive functions. Code that works fine with small datasets can fail catastrophically at scale.

### Testing Suggestions
Suggest appropriate test cases that cover edge cases and regression scenarios. This encourages a test-driven mindset and helps ensure code reliability.

## Common Pitfalls These Rules Help Avoid

1. **Over-engineering:** Adding unnecessary abstractions or patterns "just in case"
2. **Inconsistent coding styles:** Creating a patchwork codebase that's difficult to navigate
3. **Environment-specific bugs:** Issues that only appear in production but not in development
4. **Scope creep:** Making unrelated changes that introduce new bugs
5. **Technical debt accumulation:** Adding complexity without removing legacy implementations

By following these rules, your cursor agent will help produce more maintainable, reliable code while avoiding common pitfalls of AI-assisted code generation.